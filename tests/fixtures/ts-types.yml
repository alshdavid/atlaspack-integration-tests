options:
  name: ts-types
package.json:
  type: module
augmentation/augmenter/package.json: |
  {
  	"name": "augmenter",
  	"version": "1.0.0",
  	"source": "src/index.ts",
  	"types": "dist/index.d.ts",
  	"main": "dist/index.js",
  	"dependencies": {
  		"original": "1.0.0"
  	}
  }
augmentation/augmenter/src/expected.d.ts: |
  export const anotherThing: string;
  declare module "original" {
      interface Person {
          greet(): string;
      }
  }
  export const somethingElse: string;

  //# sourceMappingURL=index.d.ts.map
augmentation/augmenter/src/index.ts: |-
  import { Person } from "original";
  Person.prototype.greet = function() { return `Hello ${this.name}!` }

  export const anotherThing: string = "hello";

  declare module "original" {
    interface Person {
      greet(): string;
    }
  }

  export const somethingElse: string = "goodbye";
augmentation/original/built-src/index.d.ts: |
  export declare class Person {
      name: string;
      constructor(name: string);
  }
augmentation/original/built-src/index.js: |
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Person = void 0;
  class Person {
      constructor(name) {
          this.name = name;
      }
  }
  exports.Person = Person;
augmentation/original/package.json: |
  {
  	"name": "original",
  	"version": "1.0.0",
  	"source": "src/index.ts",
  	"main": "built-src/index.js",
      "types": "built-src/index.d.ts"
  }
augmentation/original/src/index.ts: |-
  export class Person {
      constructor(public name: string) {}
  }
augmentation/package.json: |
  {
  	"private": true,
  	"workspaces": [
  		"augmenter",
  		"original"
  	]
  }
augmentation/yarn.lock: |+
  # THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
  # yarn lockfile v1


composite/add.ts: |
  export const add = (a: number, b: number) => a + b;
composite/expected.d.ts: |
  export const add: (a: number, b: number) => number;

  //# sourceMappingURL=index.d.ts.map
composite/index.ts: |
  export * from './add';
composite/package.json: |
  {
    "name": "ts-composite",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/index.d.ts"
  }
composite/tsconfig.json: |
  {
    "compilerOptions": {
      "composite": true,
      "incremental": true
    },
    "files": [
      "index.ts",
      "add.ts"
    ],
    "references": []
  }
composite/yarn.lock: ""
error/file2.ts: |
  type Snapshot<T> = {
    readonly [K in keyof T]: Snapshot<T[K]>;
  };

  export function snapShot<V>(): Snapshot<V> {
    return 1 as any;
  }
error/index.ts: |
  import { snapShot } from "./file2";

  export interface State {
    value: any;
  }

  type ContextType = ReturnType<typeof snapShot<State>>;
  function id<T>(v: T) {
    return v;
  }
  const Context = id<ContextType | null>(null);

  export function useStateContext() {
    return Context;
  }
error/package.json: |
  {
    "name": "ts-types-error",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts",
    "dependencies": {
      "react": "*"
    }
  }
error/yarn.lock: ""
exporting-overload/expected.d.ts: |
  import { Named1, Named2 } from "external";
  export function overloaded(arg: string): Named1;
  export function overloaded(arg: number): Named2;

  //# sourceMappingURL=types.d.ts.map
exporting-overload/index.ts: |
  import {Named1, Named2} from 'external';

  export function overloaded(arg: string): Named1;
  export function overloaded(arg: number): Named2;
  export function overloaded(arg: unknown): unknown {
    return {};
  }
exporting-overload/package.json: |
  {
    "name": "ts-types-exporting-overload",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts",
    "dependencies": {
      "external": "*"
    }
  }
exporting-overload/yarn.lock: ""
exporting/expected.d.ts: |
  declare class Message {
      msg: string;
      constructor(msg: string);
  }
  export function createMessage(msg: string): Message;
  export interface Test {
      foo: number;
  }
  export interface Params {
      bar: number;
  }
  export var a: number, b: number;
  export function toUpperCase(foo: string): string;
  declare const _default: "test";
  export default _default;

  //# sourceMappingURL=types.d.ts.map
exporting/index.ts: |
  export {createMessage} from './message';
  export * from './other';
  export {test as toUpperCase, default} from './test';
exporting/message.ts: |
  export class Message {
    msg: string;
    constructor(msg: string) {
      this.msg = msg;
    }
  }

  export function createMessage(msg: string) {
    return new Message(msg);
  }

  export default 'unused';
exporting/other.ts: |
  export interface Test {
    foo: number;
  }

  export interface Params {
    bar: number;
  }

  export var a = 2, b = 5;
  export default function (p: Params) {
    return p.bar;
  }
exporting/package.json: |-
  {
    "name": "ts-types-exporting",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
exporting/test.ts: |
  export function test(foo: string) {
    return foo.toUpperCase();
  }

  export default 'test';
exporting/yarn.lock: ""
externals/expected.d.ts: |
  import * as React from "react";
  import { ReactNode } from "react";
  import External from "external";
  import Default, { Named } from "other-external";
  interface Props {
      children: ReactNode;
  }
  export const Component: React.FC<Props>;
  export { External, Default, Named };

  //# sourceMappingURL=types.d.ts.map
externals/index.tsx: |
  import {ReactNode} from 'react';
  import * as React from 'react';
  import {OtherComponent} from './other';
  import External from 'external';
  import Default, {Named} from 'other-external';

  interface Props {
    children: ReactNode
  }

  export const Component: React.FC<Props> = (props) => {
    return <OtherComponent>{props.children}</OtherComponent>;
  }

  export {External, Default, Named};
externals/other.tsx: |
  import * as React from 'react';
  import {ReactNode} from 'react';

  interface OtherProps {
    children: ReactNode
  }

  export function OtherComponent(props: OtherProps) {
    return <div>{props.children}</div>;
  }
externals/package.json: |-
  {
    "name": "ts-types-externals",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts",
    "dependencies": {
      "react": "*",
      "external": "*",
      "other-external": "*"
    }
  }
externals/yarn.lock: ""
import-export-collision/expected.d.ts: |
  import { Test as _Test1 } from "external";
  export class Test implements _Test1 {
  }

  //# sourceMappingURL=types.d.ts.map
import-export-collision/index.ts: |
  import {Test as ITest} from 'external';
  export class Test implements ITest {}
import-export-collision/package.json: |-
  {
    "name": "ts-types-externals",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
import-export-collision/yarn.lock: ""
importing-collision/expected.d.ts: |
  declare function _log1(message: string): void;
  declare function xyz(message: number): void;
  export function log(f: typeof _log1 | typeof xyz): void;

  //# sourceMappingURL=types.d.ts.map
importing-collision/index.ts: |
  import { log as logFn1 } from "./other1";
  import { log as logFn2 } from "./other2";

  export function log(f: typeof logFn1 | typeof logFn2) {
    logFn1("1");
    logFn2(1);
  }
importing-collision/other1.ts: |
  export function log(message: string) {}
importing-collision/other2.ts: |
  function xyz(message: number) {}
  export { xyz as log };
importing-collision/package.json: |-
  {
    "name": "ts-types-importing",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
importing-collision/yarn.lock: ""
importing/expected.d.ts: |
  interface Test {
      foo: number;
  }
  export interface File {
      name: string;
  }
  declare class Message {
      msg: string;
      constructor(msg: string);
  }
  export function foo(f: Test): number;
  export function file(f: File): Message;

  //# sourceMappingURL=types.d.ts.map
importing/index.ts: |
  import {Test as Foo} from './other';
  import type {File} from './nested/file';
  import * as ns from './namespace';

  export function foo(f: Foo) {
    return f.foo;
  }

  export function file(f: File) {
    return new ns.Message(f.name);
  }

  export {File};
importing/namespace.ts: |
  export class Message {
    msg: string;
    constructor(msg: string) {
      this.msg = msg;
    }
  }

  export function createMessage(msg: string) {
    return new Message(msg);
  }
importing/nested/file.ts: |
  export interface File {
    name: string;
  }
importing/other.ts: |
  export interface Test {
    foo: number;
  }

  export interface Params {
    bar: number;
  }

  export var a = 2, b = 5;
  export default function () {}
importing/package.json: |-
  {
    "name": "ts-types-importing",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
importing/yarn.lock: ""
main/expected.d.ts: |
  type Params = {
      hello: number;
  };
  interface Hello {
      yo: string;
  }
  export class Test {
      test(hello: Hello): string;
  }
  export default function test(params: Params): number;
  export function foo(): number;
  export var x: number;
  export var hi: number;
  export declare namespace mod {
      function bar(): number;
  }

  //# sourceMappingURL=types.d.ts.map
main/index.ts: |-
  type Params = {
    hello: number;
  };

  interface Hello {
    yo: string;
  }

  export class Test {
    test(hello: Hello) {
      return hello.yo;
    }
  }

  export default function test(params: Params) {
    return params.hello;
  }

  export function foo() {
    return 2;
  }

  var x = 2;
  var p = x + 2, q = 3;
  export {p as hi, x};

  export module mod {
    export function bar() {
      return 2;
    }
  }
main/package.json: |-
  {
    "name": "ts-types-main",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
main/yarn.lock: ""
monorepo/a/package.json: |
  {
  	"name": "a",
  	"version": "0.0.0",
  	"source": "src/index.ts",
  	"types": "dist/index.d.ts"
  }
monorepo/a/src/index.ts: |
  import { B } from "b";

  export default function () {
  	return new B();
  }
monorepo/b/package.json: |
  {
  	"name": "b",
  	"version": "0.0.0",
  	"source": "src/index.ts",
  	"types": "dist/index.d.ts",
  	"main": "dist/index.js"
  }
monorepo/b/src/index.ts: |
  export class B {}
  export * from "./other";
monorepo/b/src/other.ts: |
  export class C {}
monorepo/package.json: |
  {
  	"private": true,
  	"workspaces": [
  		"a",
  		"b"
  	]
  }
monorepo/yarn.lock: |+
  # THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
  # yarn lockfile v1


private/expected.d.ts: |
  export class Test {
      _public: string;
      protected _protected: string;
  }

  //# sourceMappingURL=types.d.ts.map
private/index.ts: |
  export class Test {
    _public: string;
    private _private: string;
    protected _protected: string;
  }
private/package.json: |-
  {
    "name": "ts-types-private",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
private/yarn.lock: ""
promise-or-value/expected.d.ts: |
  export type Callback = () => Promise<any> | any;

  //# sourceMappingURL=types.d.ts.map
promise-or-value/index.ts: |
  export type Callback = () => Promise<any> | any;
promise-or-value/package.json: |
  {
    "name": "ts-promise-or-value",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
promise-or-value/tsconfig.json: |
  {
    "compilerOptions": {
      "lib": ["dom", "es2017"],
    }
  }
promise-or-value/yarn.lock: ""
re-exporting-aggregating/expected.d.ts: |
  type fuga = "fuga";
  export type Baz = `${fuga}`;

  //# sourceMappingURL=types.d.ts.map
re-exporting-aggregating/hoge/bar.ts: export type bar = 'bar';
re-exporting-aggregating/hoge/fuga.ts: export type fuga = "fuga";
re-exporting-aggregating/hoge/index.ts: |-
  export * from "./bar";
  export * from "./fuga";
re-exporting-aggregating/index.ts: |-
  import { fuga } from './hoge';
  export type Baz = `${fuga}`
re-exporting-aggregating/package.json: |-
  {
    "name": "ts-types-re-exporting-aggregating",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
re-exporting-aggregating/yarn.lock: ""
windows-paths/expected.d.ts: |
  type Params = {
      hello: number;
  };
  interface Hello {
      yo: string;
  }
  export class Test {
      test(hello: Hello): string;
  }
  export function test(params: Params): number;
  export function foo(): number;
  export var x: number;
  export var hi: number;
  export declare namespace mod {
      function bar(): number;
  }

  //# sourceMappingURL=types.d.ts.map
windows-paths/index.ts: |
  export * from './src/index';
windows-paths/package.json: |-
  {
    "name": "ts-types-main",
    "private": true,
    "main": "dist/main.js",
    "types": "dist/types.d.ts"
  }
windows-paths/src/index.ts: |
  type Params = {
    hello: number;
  };

  interface Hello {
    yo: string;
  }

  export class Test {
    test(hello: Hello) {
      return hello.yo;
    }
  }

  export function test(params: Params) {
    return params.hello;
  }

  export function foo() {
    return 2;
  }

  var x = 2;
  var p = x + 2, q = 3;
  export {p as hi, x};

  export module mod {
    export function bar() {
      return 2;
    }
  }
windows-paths/tsconfig.json: |
  {
    "compilerOptions": {
      "removeComments": true,
      "baseUrl": ".",
      "paths": {
        "@atlaspack/*": ["../../*"]
      }
    }
  }
windows-paths/yarn.lock: ""
